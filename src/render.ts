import { Rect, width, height, inflate, union } from "./rect";

export type BorderStyle = {
  /**
   * How much should we offset the border from the boundary of the
   * polygon. A value of 0 is _on_ the boundary.
   */
  borderOffset: number;
  /**
   * The radius of corners in the border.
   */
  borderRadius: number;
  /**
   * Should the border be drawn on top edges?
   */
  borderTop: boolean;
  /**
   * Should the border be drawn on bottom edges?
   */
  borderBottom: boolean;
  /**
   * Should the border be drawn on left edges?
   */
  borderLeft: boolean;
  /**
   * Should the border be drawn on right edges?
   */
  borderRight: boolean;
  /**
   * The color of the border stroke.
   */
  borderStroke: string;
  /**
   * The width of the border stroke
   */
  borderWidth: number;
};

export const DEFAULT_BORDER_STYLE: BorderStyle = {
  borderOffset: 0,
  borderRadius: 0,
  borderTop: true,
  borderBottom: true,
  borderLeft: true,
  borderRight: true,
  borderStroke: "black",
  borderWidth: 1,
};

/**
 * The styles to apply to a rendering.
 */
export type SVGStyle = {
  fill: string;
  borders: Partial<BorderStyle>[];
  /**
   * The color of (non-border) strokes (i.e. line segments).
   */
  stroke: string;
  debugFragmentBoundingBoxes: boolean;
};

export const DEFAULT_STYLE: SVGStyle = {
  fill: "white",
  stroke: "black",
  borders: [],
  debugFragmentBoundingBoxes: false,
}

export abstract class Render {
  /**
   * Mutate the given `svg`, adding elements which represent `this`.
   */
  abstract render(svg: Svg, sty: SVGStyle): void;

  /**
   * Find a bounding box which encloses the SVG generated by `render`.
   */
  abstract boundingBox(): Rect | null;

  /**
   * Stack `a` above `this`.
   */
  stack(a: Render): Render {
    return new Stack(this, a);
  }

  /**
   * Apply styles to this rendering.
   */
  withStyles(sty: Partial<SVGStyle>): Render {
    return new WithStyle(this, sty);
  }
}

/**
 * Given a value which extends `Render`, produce an svg string
 * representing the value. Accepts an optional `window` which allows
 * this function to operate in contexts where we don't have a document
 * (such as node).
 *
 * @param a The value to render as an SVG.
 * @param window The optional window object to use instead of the
 * default window.
 * @param debugFragmentBoundingBoxes An optional flag which, when
 * true, will instruct the renderer to include renderings of the base
 * fragment rectangles in the output.
 * @returns An SVG, serialized as a string.
 */
export function toSVG<A extends Render>(
  a: A,
  padding?: number,
  debugFragmentBoundingBoxes?: boolean
): string {
  if(!padding) {
    padding = 0;
  }

  const svg = new Svg();
  const sty = DEFAULT_STYLE;
  if(debugFragmentBoundingBoxes !== undefined) {
    sty.debugFragmentBoundingBoxes = debugFragmentBoundingBoxes;
  }
  a.render(svg, sty);

  let bbox = a.boundingBox();
  if(bbox) {
    bbox = inflate(bbox, padding);
    svg.viewbox(bbox);
    svg.width(width(bbox));
  }

  return svg.build();
}

/**
 * A stack of two `Render`able things.
 */
class Stack extends Render {
  private a: Render;
  private b: Render;

  constructor(a: Render, b: Render) {
    super();
    this.a = a;
    this.b = b;
  }

  render(svg: Svg, sty: SVGStyle) {
    this.a.render(svg, sty);
    this.b.render(svg, sty);
  }

  boundingBox(): Rect | null {
    const aBBox = this.a.boundingBox();
    const bBBox = this.b.boundingBox();
    if(bBBox === null) {
      return aBBox;
    }
    if(aBBox === null) {
      return bBBox;
    }
    return union(aBBox, bBBox);
  }
}

class WithStyle extends Render {
  private a: Render;
  private sty: Partial<SVGStyle>;

  constructor(a: Render, sty: Partial<SVGStyle>) {
    super();
    this.a = a;
    this.sty = sty;
  }

  render(svg: Svg, sty: SVGStyle) {
    this.a.render(svg, { ...sty, ...this.sty });
  }

  boundingBox(): Rect | null {
    return this.a.boundingBox();
  }
}

export class EmptyRendering extends Render {
  render(_svg: Svg, _sty: SVGStyle) {
    // Nothing to do.
  }

  boundingBox(): Rect | null {
    return null;
  }
}

type SVGTextElement = {
  type: "text";
  text: string;
  x: number;
  y: number;
  style?: string;
};

interface SVGFillAndStroke {
  fill?: string;
  stroke?: string;
  strokeWidth?: number;
};

type SVGRectElement = {
  type: "rect";
  width: number;
  height: number;
  x: number;
  y: number;
} & SVGFillAndStroke;

type SVGPathElement = {
  type: "path";
  d: string;
} & SVGFillAndStroke;

type SVGLineElement = {
  type: "line";
  x1: number;
  x2: number;
  y1: number;
  y2: number;
} & SVGFillAndStroke;

type SVGElement = SVGTextElement | SVGRectElement | SVGPathElement | SVGLineElement;

function sanitize(str: string) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function buildElement(elt: SVGElement): string {
  let strokeProperties = "";
  if(elt.type === "rect" || elt.type === "path" || elt.type === "line") {
    if(elt.fill !== undefined) {
      strokeProperties += ` fill=\"${elt.fill}\"`;
    }

    if(elt.stroke !== undefined) {
      strokeProperties += ` stroke=\"${elt.stroke}\"`;
    }

    if(elt.strokeWidth !== undefined) {
      strokeProperties += ` stroke-width=\"${elt.strokeWidth}\"`;
    }
  }


  switch(elt.type) {
    case "text": {
      let out = `<text x=\"${elt.x}\" y=\"${elt.y}\"`;
      if(elt.style) {
        out += ` style=\"${elt.style}\"`;
      }
      const text = sanitize(elt.text)
      return `${out}>${text}</text>`;
    };
    case "rect":
      return `<rect x=\"${elt.x}\" y=\"${elt.y}\" width=\"${elt.width}\" height=\"${elt.height}\"${strokeProperties} />`;
    case "path":
      return `<path d=\"${elt.d}\"${strokeProperties} />`;
    case "line":
      return `<line x1=\"${elt.x1}\" y1=\"${elt.y1}\" x2=\"${elt.x2}\" y2=\"${elt.y2}\"${strokeProperties} />`;
  }
}

export class Svg {
  private elements: SVGElement[];
  private _viewbox: Rect | undefined;
  private _width: number | undefined;
  private _height: number | undefined;

  constructor() {
    this.elements = [];
  }

  /**
   * Set or get the SVG's viewbox.
   */
  viewbox(vb?: Rect) {
    if(vb !== undefined) {
      this._viewbox = vb;
    }
    return this._viewbox;
  }

  /**
   * Set or get the SVG's width.
   */
  width(w?: number) {
    if(w !== undefined) {
      this._width = w;
    }
    return this._width;
  }

  /**
   * Set or get the SVG's height.
   */
  height(h?: number) {
    if(h !== undefined) {
      this._height = h;
    }
    return this._height;
  }

  private append(e: SVGElement) {
    this.elements.push(e);
  }

  text(s: string): SvgTextBuilder {
    const elt: SVGTextElement = { type: "text", text: s, x: 0, y: 0 };
    this.append(elt);
    return new SvgTextBuilder(elt);
  }

  rect(w: number, h: number) {
    const elt: SVGRectElement = { type: "rect", width: w, height: h, x: 0, y: 0 };
    this.append(elt);
    return new SvgRectBuilder(elt);
  }

  path(p: string) {
    const elt: SVGPathElement = { type: "path", d: p };
    this.append(elt);
    return new SvgPathBuilder(elt);
  }

  line(x1: number, y1: number, x2: number, y2: number) {
    const elt: SVGLineElement = { type: "line", x1, y1, x2, y2 };
    this.append(elt);
    return new SvgLineBuilder(elt);
  }

  build(): string {
    let out = "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"";

    if(this._width !== undefined) {
      out += ` width=\"${this._width}\"`;
    }

    if(this._height !== undefined) {
      out += ` height=\"${this._height}\"`;
    }

    if(this._viewbox !== undefined) {
      const x = this._viewbox.left;
      const y = this._viewbox.top;
      const w = width(this._viewbox);
      const h = height(this._viewbox);
      out += ` viewBox=\"${x} ${y} ${w} ${h}\"`;
    }

    return `${out}>${this.elements.map(buildElement).join("")}</svg>`;
  }
}

class FillAndStrokeBuilder {
  private fs: SVGFillAndStroke;
  constructor(fs: SVGFillAndStroke) {
    this.fs = fs;
  }

  fill(f?: string) {
    this.fs.fill = f;
    return this;
  }

  stroke(s?: string) {
    this.fs.stroke = s;
    return this;
  }

  strokeWidth(w?: number) {
    this.fs.strokeWidth = w;
    return this;
  }
}

class SvgRectBuilder extends FillAndStrokeBuilder {
  private it: SVGRectElement;
  constructor(it: SVGRectElement) {
    super(it);
    this.it = it;
  }

  move(x: number, y: number) {
    this.it.x = x;
    this.it.y = y;
    return this;
  }
}

class SvgPathBuilder extends FillAndStrokeBuilder {
  constructor(it: SVGPathElement) {
    super(it);
  }
}

class SvgLineBuilder extends FillAndStrokeBuilder {
  constructor(it: SVGLineElement) {
    super(it);
  }
}

class SvgTextBuilder {
  private it: SVGTextElement;
  constructor(it: SVGTextElement) {
    this.it = it;
  }

  move(x: number, y: number) {
    this.it.x = x;
    this.it.y = y;
    return this;
  }

  font(family: string, size: number) {
    // HACK: These style properties should be set in a more principled
    // way.
    this.it.style = `font-family:${family};font-size: ${size};white-space: pre`;
    return this;
  }
}
